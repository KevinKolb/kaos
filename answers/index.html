<html>
<head>
<link rel="icon" href="../8ball.svg" type="image/svg+xml" onerror="this.style.display='none'">
<title>Answers MAGA Hate Ball</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: #4662bd;
  overflow: hidden;
  font-family: "Courier New", Courier, "Lucida Console", monospace;
  display: flex;
  align-items: center;
  justify-content: center;
}

#text-container {
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background: #4662bd;
}

#zoom-text {
  position: absolute;
  color: white;
  font-weight: bold;
  text-transform: uppercase;
  text-align: center;
  left: 50%;
  transform: translate(-50%, 0);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  text-shadow:
    0 1px 0 rgba(150, 180, 255, 0.4),
    0 -1px 2px rgba(0, 0, 0, 0.6),
    0 3px 3px rgba(0, 0, 0, 0.7),
    0 6px 6px rgba(0, 0, 0, 0.5),
    0 10px 10px rgba(0, 0, 0, 0.3),
    0 0 15px rgba(100, 150, 255, 0.5);
  filter: blur(20px);
  opacity: 0;
  transition: filter 1.5s ease-out, opacity 1.5s ease-out, transform 1.5s ease-out; /* intro */
}

/* Line breaks defined per answer using | delimiter */
.word {
  display: block;
  white-space: nowrap;
}

.word.wrap {
  white-space: normal;
  word-wrap: break-word;
}

#measure {
  position: absolute;
  left: -9999px;
  top: -9999px;
  visibility: hidden;
  white-space: nowrap;
  font-family: "Courier New", Courier, "Lucida Console", monospace;
  font-weight: bold;
  letter-spacing: 0.1em;
  word-spacing: -0.2em;
  text-transform: uppercase;
}

.bubble {
  position: absolute;
  bottom: -20px;
  --drift-start: 0px;
  --drift-end: 0px;
  background:
    radial-gradient(circle at 30% 28%, rgba(150, 180, 255, 0.7), rgba(100, 140, 220, 0.15) 30%, rgba(60, 100, 180, 0.12) 45%, rgba(30, 60, 120, 0.08) 70%, rgba(15, 30, 60, 0) 90%),
    radial-gradient(circle at 70% 75%, rgba(80, 120, 200, 0.3), rgba(30, 50, 100, 0.1) 55%, rgba(15, 25, 50, 0) 85%);
  border-radius: 50%;
  box-shadow:
    inset 0 0 6px rgba(150, 180, 255, 0.35),
    inset 0 0 18px rgba(60, 100, 180, 0.2),
    0 2px 8px rgba(10, 20, 40, 0.4);
  mix-blend-mode: screen;
  filter: saturate(1.2);
  animation: rise linear infinite;
  pointer-events: none;
}

.bubble.front {
  z-index: 10;
}

.bubble.back {
  z-index: -1;
}

@keyframes rise {
  0% {
    transform: translate(var(--drift-start), 0) scale(1);
    opacity: 0.6;
  }
  50% {
    opacity: 0.4;
  }
  100% {
    transform: translate(var(--drift-end), -100vh) scale(0.55);
    opacity: 0;
  }
}

@keyframes riseMeander {
  0% {
    transform: translate(var(--drift-start), 0) scale(1);
    opacity: 0.6;
  }
  50% {
    transform: translate(calc(var(--drift-start) + var(--meander-amt)), -50vh) scale(0.75);
    opacity: 0.4;
  }
  100% {
    transform: translate(var(--drift-end), -100vh) scale(0.55);
    opacity: 0;
  }
}
</style>
</head>
<body>
<video id="intro-video" autoplay muted playsinline webkit-playsinline preload="auto" style="position:absolute; width:100%; height:100%; object-fit:cover; z-index:100;" playsinline>
  <source src="../videos/kaos_water.mp4" type="video/mp4">
</video>
<div id="text-container">
  <div id="zoom-text"></div>
</div>
<script>
  // SEQUENTIAL MODE: cycle through all answers
  const textsWithRatings = [
    { text: "COVFEFE", align: "center" },                                           
    { text: "WITCH|HUNT", align: "center" },                                        
    { text: "IT'S A|HOAX", align: "center" },                                       
    { text: "NO.|IT'S FAKE|NEWS", align: "center" },                                
    { text: "NO.|QUIET|PIGGY", align: "center" },                                   
    { text: "MANY PEOPLE ARE|SAYING NO", align: "center" },                         
    { text: "IT'S A|SCAM", align: "center" },                                       
    { text: "WHAT A STUPID|QUESTION.|YES", align: "center" },                       
    { text: "THEY'RE EATING|THE DOGS!", align: "center" },                          
    { text: "THE FAILING|NEW YORK TIMES|SAYS YES", align: "center" },               
  ];

  // Flow: kaos_water video > bubbles pause > Answer 1 > bubbles pause > Answer 2 > ... > loop
  // States: 'video', 'bubbles', 'answer'
  let currentAnswerIndex = 0;
  let currentState = 'video';
  let stepTimeout = null;
  let outroTimeout = null;
  let bubbleInterval = null;

  const zoomText = document.getElementById("zoom-text");
  const textContainer = document.getElementById("text-container");
  const introVideo = document.getElementById('intro-video');
  const measure = document.createElement("div");
  measure.id = "measure";
  document.body.appendChild(measure);

  function createBubble() {
    const count = Math.random() < 0.5 ? 12 : 6;
    for (let i = 0; i < count; i++) {
      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.style.left = Math.random() * 100 + "%";
      const rand = Math.random();
      const size = rand < 0.02 ? Math.random() * 300 + 500
        : rand < 0.08 ? Math.random() * 200 + 250
        : rand < 0.25 ? Math.random() * 150 + 80
        : Math.random() * 30 + 8;
      bubble.style.width = bubble.style.height = size + "px";
      bubble.style.bottom = (-size - 20) + "px";
      bubble.classList.add(Math.random() < 0.2 ? 'front' : 'back');
      bubble.style.animationDuration = (Math.random() * 15 + 3) + "s";
      bubble.style.animationDelay = (Math.random() * 1.2) + "s";
      bubble.style.setProperty("--drift-start", (Math.random() * 14 - 7) + "px");
      bubble.style.setProperty("--drift-end", (Math.random() * 20 - 10) + "px");
      if (Math.random() < 0.3) {
        bubble.style.setProperty("--meander-amt", (Math.random() * 40 + 20) + "px");
        bubble.style.animationName = "riseMeander";
      }
      textContainer.appendChild(bubble);
      setTimeout(() => bubble.remove(), 14000);
    }
  }

  function ensureBubbles() {
    if (!bubbleInterval) {
      bubbleInterval = setInterval(createBubble, 600);
    }
  }

  // Hard-coded durations (ms) - keeps both screens in sync
  const VIDEO_DURATION = 6000;    // kaos_water.mp4 (matches KAOS_SIGN.mp4)
  const BUBBLE_DURATION = 13000;  // question (6s) + fade (1s) + ZOLTAR_ORANGE_2 (6s)
  const ANSWER_DURATION = 6000;   // matches down_arrow.mp4
  
  // Total cycle time per answer
  const CYCLE_TIME = VIDEO_DURATION + BUBBLE_DURATION + ANSWER_DURATION + BUBBLE_DURATION; // 38000ms
  const TOTAL_CYCLE = CYCLE_TIME * textsWithRatings.length; // Full loop
  
  // Clock-based sync: calculate position in cycle from system time
  let syncCheckInterval = null;

  function clearTimers() {
    clearTimeout(stepTimeout);
    clearTimeout(outroTimeout);
    stepTimeout = null;
    outroTimeout = null;
  }
  
  function getCurrentCyclePosition() {
    const now = Date.now();
    const positionInCycle = now % TOTAL_CYCLE;
    return positionInCycle;
  }
  
  function syncToClockPosition() {
    const position = getCurrentCyclePosition();
    
    // Determine which answer and what phase we should be in
    const answerCycle = Math.floor(position / CYCLE_TIME);
    const positionInAnswer = position % CYCLE_TIME;
    
    currentAnswerIndex = answerCycle;
    
    if (positionInAnswer < VIDEO_DURATION) {
      // Should be in video - only play from start, don't seek
      if (positionInAnswer < 500) {
        // Close enough to start, play the video
        playKaosWater(VIDEO_DURATION);
      } else {
        // Too far in, skip to next phase
        const timeLeft = (VIDEO_DURATION + BUBBLE_DURATION) - positionInAnswer;
        ensureBubbles();
        showBubblePause(true, timeLeft);
      }
    } else if (positionInAnswer < VIDEO_DURATION + BUBBLE_DURATION) {
      // Should be in first bubble pause
      const timeLeft = (VIDEO_DURATION + BUBBLE_DURATION) - positionInAnswer;
      ensureBubbles();
      showBubblePause(true, timeLeft);
    } else if (positionInAnswer < VIDEO_DURATION + BUBBLE_DURATION + ANSWER_DURATION) {
      // Should be in answer
      const timeLeft = (VIDEO_DURATION + BUBBLE_DURATION + ANSWER_DURATION) - positionInAnswer;
      ensureBubbles();
      showAnswer(timeLeft);
    } else {
      // Should be in second bubble pause
      const timeLeft = CYCLE_TIME - positionInAnswer;
      ensureBubbles();
      showBubblePause(false, timeLeft);
    }
  }

  // Step 1: Play kaos_water video
  function playKaosWater(duration = VIDEO_DURATION) {
    currentState = 'video';
    clearTimers();

    // Hide any text
    zoomText.style.opacity = '0';
    zoomText.style.transition = 'none';

    // Show and play video from start
    introVideo.style.display = 'block';
    introVideo.currentTime = 0;
    
    introVideo.play().catch(e => {
      console.log('Video play failed:', e);
      // If play fails, skip to next phase
      introVideo.style.display = 'none';
      ensureBubbles();
      showBubblePause(true);
    });

    // Hard cutoff after duration
    stepTimeout = setTimeout(() => {
      introVideo.pause();
      introVideo.style.display = 'none';
      ensureBubbles();
      showBubblePause(true);
    }, duration);
  }

  // Step 2: Bubbles-only pause between video/answers
  function showBubblePause(beforeAnswer, duration = BUBBLE_DURATION) {
    currentState = 'bubbles';

    // Make sure text is hidden
    zoomText.style.opacity = '0';
    zoomText.style.transition = 'none';

    stepTimeout = setTimeout(() => {
      if (beforeAnswer) {
        showAnswer();
      } else {
        // After an answer: advance to next answer or loop
        currentAnswerIndex++;
        if (currentAnswerIndex >= textsWithRatings.length) {
          currentAnswerIndex = 0;
          playKaosWater();
        } else {
          showAnswer();
        }
      }
    }, duration);
  }

  // Step 3: Show answer text
  function showAnswer(duration = ANSWER_DURATION) {
    currentState = 'answer';
    const item = textsWithRatings[currentAnswerIndex];

    const hasPipes = item.text.includes("|");
    const lines = hasPipes ? item.text.split("|") : item.text.split(" ");
    const useWordWrap = !hasPipes && lines.length >= 4;
    const processedLines = useWordWrap ? findBestLineBreaks(lines) : lines;

    const elapsed = ANSWER_DURATION - duration;
    const introDone = elapsed >= 1500;
    
    zoomText.innerHTML = processedLines.map(line => `<span class="word">${line}</span>`).join("");
    zoomText.style.fontSize = item.fontSize || getTextStyle(processedLines, false).size;

    if (!introDone) {
      // Still in intro phase
      zoomText.style.transition = "none";
      zoomText.style.filter = "blur(20px)";
      zoomText.style.opacity = "0";
      zoomText.style.transform = "translate(-50%, 0) scale(0.6) rotate(-8deg)";
      
      setTimeout(() => {
        zoomText.style.transition = "filter 1.5s ease-out, opacity 1.5s ease-out, transform 1.5s ease-out";
        zoomText.style.filter = "blur(0)";
        zoomText.style.opacity = "1";
        zoomText.style.transform = "translate(-50%, 0) scale(1) rotate(0deg)";
      }, 10);
    } else {
      // Already past intro, show immediately
      zoomText.style.transition = "none";
      zoomText.style.filter = "blur(0)";
      zoomText.style.opacity = "1";
      zoomText.style.transform = "translate(-50%, 0) scale(1) rotate(0deg)";
    }

    // Outro transition
    const outroDelay = Math.max(0, duration - 1500);
    outroTimeout = setTimeout(() => {
      const exitRotate = Math.random() * 30 - 15;
      zoomText.style.transition = "filter 1.5s ease-in, opacity 1.5s ease-in, transform 1.5s ease-in";
      zoomText.style.filter = "blur(18px)";
      zoomText.style.opacity = "0";
      zoomText.style.transform = `translate(-50%, 0) scale(0.35) rotate(${exitRotate}deg)`;
    }, outroDelay);

    // After remaining duration, go to bubble pause
    stepTimeout = setTimeout(() => {
      showBubblePause(false);
    }, duration);
  }

  // Text sizing helpers
  function getAvailableWidth() {
    return (textContainer.clientWidth || window.innerWidth) * 0.95;
  }

  function getAvailableHeight() {
    return (textContainer.clientHeight || window.innerHeight) * 0.95;
  }

  function measureWord(word, size) {
    measure.style.fontSize = size + "vmin";
    measure.textContent = word;
    return measure.getBoundingClientRect().width;
  }

  function measureLineHeight(size) {
    measure.style.fontSize = size + "vmin";
    measure.textContent = "X";
    return measure.getBoundingClientRect().height * 1.1;
  }

  function getTextStyle(lines, useWordWrap = false) {
    const availableWidth = getAvailableWidth();
    const availableHeight = getAvailableHeight();

    if (useWordWrap) {
      const words = lines[0].split(" ");
      const getLongestWord = (s) => Math.max(...words.map(w => measureWord(w, s)));
      let size = 120;
      while (size > 4) {
        const longestWordWidth = getLongestWord(size);
        if (longestWordWidth > availableWidth) { size--; continue; }
        const lineHeight = measureLineHeight(size);
        const wordsPerLine = Math.floor(availableWidth / (longestWordWidth * 0.6));
        const estimatedLines = Math.ceil(words.length / Math.max(wordsPerLine, 1));
        if (lineHeight * estimatedLines > availableHeight) { size--; continue; }
        break;
      }
      return { size: size + "vmin" };
    }

    const getWidestLine = (s) => Math.max(...lines.map(line => measureWord(line, s)));
    let size = 120;
    while (size > 4 && (getWidestLine(size) > availableWidth || measureLineHeight(size) * lines.length > availableHeight)) {
      size--;
    }
    return { size: size + "vmin" };
  }

  function balanceLines(words, numLines) {
    if (numLines >= words.length) return words.map(w => [w]);
    const lines = [];
    const wordsPerLine = words.length / numLines;
    let idx = 0;
    for (let i = 0; i < numLines; i++) {
      const targetEnd = Math.round((i + 1) * wordsPerLine);
      lines.push(words.slice(idx, targetEnd).join(" "));
      idx = targetEnd;
    }
    return lines;
  }

  function findBestLineBreaks(words) {
    const wordCount = words.length;
    let bestLines = words;
    let bestVariance = Infinity;
    for (let numLines = 2; numLines < wordCount; numLines++) {
      const lines = balanceLines(words, numLines);
      const lengths = lines.map(l => l.length);
      const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
      const variance = lengths.reduce((sum, len) => sum + Math.pow(len - avg, 2), 0) / lengths.length;
      if (variance < bestVariance) {
        bestVariance = variance;
        bestLines = lines;
      }
    }
    return bestLines;
  }

  // Spacebar restarts from beginning and makes Chrome fullscreen
  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      
      // Request fullscreen
      if (!document.fullscreenElement) {
        document.documentElement.requestFullscreen().catch(err => {
          console.log('Fullscreen request failed:', err);
        });
      }
      
      // Stop everything
      clearTimers();
      if (bubbleInterval) {
        clearInterval(bubbleInterval);
        bubbleInterval = null;
      }
      if (syncCheckInterval) {
        clearInterval(syncCheckInterval);
        syncCheckInterval = null;
      }
      
      // Hide and reset video
      introVideo.pause();
      introVideo.style.display = 'none';
      introVideo.currentTime = 0;
      
      // Clear any displayed text
      zoomText.style.opacity = '0';
      zoomText.style.transition = 'none';
      zoomText.innerHTML = '';
      
      // Reset to beginning
      currentAnswerIndex = 0;
      
      // Start fresh from video
      setTimeout(() => {
        playKaosWater();
      }, 100);
    }
  });

  // Autoplay setup
  introVideo.muted = true;
  introVideo.setAttribute('muted', '');
  introVideo.setAttribute('playsinline', '');
  introVideo.setAttribute('webkit-playsinline', '');
  introVideo.playsInline = true;

  // Start: sync to clock position
  introVideo.load();
  syncToClockPosition();
  
  // Resync every 30 seconds to prevent any drift
  syncCheckInterval = setInterval(() => {
    const position = getCurrentCyclePosition();
    const answerCycle = Math.floor(position / CYCLE_TIME);
    
    // Only resync if we've drifted to wrong answer
    if (answerCycle !== currentAnswerIndex) {
      console.log('Drift detected, resyncing...');
      clearTimers();
      syncToClockPosition();
    }
  }, 30000);
</script>
</body>
</html>
