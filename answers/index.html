<html>
<head>
<link rel="icon" href="../8ball.svg" type="image/svg+xml" onerror="this.style.display='none'">
<title>Answers MAGA Hate Ball</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: #4662bd;
  overflow: hidden;
  font-family: "Courier New", Courier, "Lucida Console", monospace;
  display: flex;
  align-items: center;
  justify-content: center;
}

#text-container {
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background: #4662bd;
}

#zoom-text {
  position: absolute;
  color: white;
  font-weight: bold;
  text-transform: uppercase;
  text-align: center;
  left: 50%;
  transform: translate(-50%, 0);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  text-shadow:
    0 1px 0 rgba(150, 180, 255, 0.4),
    0 -1px 2px rgba(0, 0, 0, 0.6),
    0 3px 3px rgba(0, 0, 0, 0.7),
    0 6px 6px rgba(0, 0, 0, 0.5),
    0 10px 10px rgba(0, 0, 0, 0.3),
    0 0 15px rgba(100, 150, 255, 0.5);
  filter: blur(20px);
  opacity: 0;
  transition: filter 1.5s ease-out, opacity 1.5s ease-out, transform 1.5s ease-out; /* intro */
}

/* Line breaks defined per answer using | delimiter */
.word {
  display: block;
  white-space: nowrap;
}

.word.wrap {
  white-space: normal;
  word-wrap: break-word;
}

#measure {
  position: absolute;
  left: -9999px;
  top: -9999px;
  visibility: hidden;
  white-space: nowrap;
  font-family: "Courier New", Courier, "Lucida Console", monospace;
  font-weight: bold;
  letter-spacing: 0.1em;
  word-spacing: -0.2em;
  text-transform: uppercase;
}

.bubble {
  position: absolute;
  bottom: -20px;
  --drift-start: 0px;
  --drift-end: 0px;
  background:
    radial-gradient(circle at 30% 28%, rgba(150, 180, 255, 0.7), rgba(100, 140, 220, 0.15) 30%, rgba(60, 100, 180, 0.12) 45%, rgba(30, 60, 120, 0.08) 70%, rgba(15, 30, 60, 0) 90%),
    radial-gradient(circle at 70% 75%, rgba(80, 120, 200, 0.3), rgba(30, 50, 100, 0.1) 55%, rgba(15, 25, 50, 0) 85%);
  border-radius: 50%;
  box-shadow:
    inset 0 0 6px rgba(150, 180, 255, 0.35),
    inset 0 0 18px rgba(60, 100, 180, 0.2),
    0 2px 8px rgba(10, 20, 40, 0.4);
  mix-blend-mode: screen;
  filter: saturate(1.2);
  animation: rise linear infinite;
  pointer-events: none;
}

.bubble.front {
  z-index: 10;
}

.bubble.back {
  z-index: -1;
}

@keyframes rise {
  0% {
    transform: translate(var(--drift-start), 0) scale(1);
    opacity: 0.6;
  }
  50% {
    opacity: 0.4;
  }
  100% {
    transform: translate(var(--drift-end), -100vh) scale(0.55);
    opacity: 0;
  }
}

@keyframes riseMeander {
  0% {
    transform: translate(var(--drift-start), 0) scale(1);
    opacity: 0.6;
  }
  50% {
    transform: translate(calc(var(--drift-start) + var(--meander-amt)), -50vh) scale(0.75);
    opacity: 0.4;
  }
  100% {
    transform: translate(var(--drift-end), -100vh) scale(0.55);
    opacity: 0;
  }
}
</style>
</head>
<body>
<video id="intro-video" autoplay muted playsinline webkit-playsinline preload="auto" style="position:absolute; width:100%; height:100%; object-fit:cover; z-index:100;" playsinline>
  <source src="../videos/kaos_water.mp4" type="video/mp4">
</video>
<div id="text-container">
  <div id="zoom-text"></div>
</div>
<script>
  // SEQUENTIAL MODE: cycle through all answers
  const textsWithRatings = [
    { text: "GROCERIES", align: "center" },                                         // A
    { text: "BIGLY", align: "center" },                                             // B
    { text: "COVFEFE", align: "center" },                                           // C
    { text: "WITCH|HUNT", align: "center" },                                        // D
    { text: "IT'S|RIGGED", align: "center" },                                       // E
    { text: "IT'S A|HOAX", align: "center" },                                       // F
    { text: "NO.|IT'S FAKE|NEWS", align: "center" },                                // G
    { text: "THERE'S NO|COLLUSION", align: "center" },                              // H
    { text: "NO.|QUIET|PIGGY", align: "center" },                                   // I
    { text: "EVERYONE|AGREES", align: "center" },                                   // J
    { text: "NO.|SAD!", align: "center" },                                          // K
    { text: "YES.|DRILL BABY|DRILL", align: "center" },                             // L
    { text: "MANY PEOPLE ARE|SAYING NO", align: "center" },                         // M
    { text: "UNKNOWN.|JUST YELL|LOSERS", align: "center" },                         // N
    { text: "MANY PEOPLE ARE|SAYING YES", align: "center" },                        // O
    { text: "YES.|IT'S GONNA|BE HUGE", align: "center" },                           // P
    { text: "IT'S A|SCAM", align: "center" },                                       // Q
    { text: "WHAT A STUPID|QUESTION.|YES", align: "center" },                       // R
    { text: "ASK AGAIN LATER|DO MORE TARIFFS", align: "center" },                   // S
    { text: "JUST SAY|RUSSIA|RUSSIA|RUSSIA", align: "center" },                     // T
    { text: "YES. TELL PEOPLE TO|DRINK BLEACH", align: "center" },                  // U
    { text: "THEY'RE EATING|THE DOGS!", align: "center" },                          // V
    { text: "THE FAILING|NEW YORK TIMES|SAYS YES", align: "center" },               // W
    { text: "THANK YOU FOR YOUR|ATTENTION IN|THIS MATTER.|NO", align: "center" },   // X
    { text: "TBD|ANSWER 1", align: "center" },                                      // Y
    { text: "TBD|ANSWER 2", align: "center" },                                      // Z
    { text: "TBD|ANSWER 3", align: "center" },                                      // AA
  ];

  // Flow: kaos_water video > bubbles pause > Answer 1 > bubbles pause > Answer 2 > ... > loop
  // States: 'video', 'bubbles', 'answer'
  let currentAnswerIndex = 0;
  let currentState = 'video';
  let frozen = false;
  let stepTimeout = null;
  let outroTimeout = null;
  let bubbleInterval = null;

  const zoomText = document.getElementById("zoom-text");
  const textContainer = document.getElementById("text-container");
  const introVideo = document.getElementById('intro-video');
  const measure = document.createElement("div");
  measure.id = "measure";
  document.body.appendChild(measure);

  function createBubble() {
    const count = Math.random() < 0.5 ? 12 : 6;
    for (let i = 0; i < count; i++) {
      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.style.left = Math.random() * 100 + "%";
      const rand = Math.random();
      const size = rand < 0.02 ? Math.random() * 300 + 500
        : rand < 0.08 ? Math.random() * 200 + 250
        : rand < 0.25 ? Math.random() * 150 + 80
        : Math.random() * 30 + 8;
      bubble.style.width = bubble.style.height = size + "px";
      bubble.style.bottom = (-size - 20) + "px";
      bubble.classList.add(Math.random() < 0.2 ? 'front' : 'back');
      bubble.style.animationDuration = (Math.random() * 15 + 3) + "s";
      bubble.style.animationDelay = (Math.random() * 1.2) + "s";
      bubble.style.setProperty("--drift-start", (Math.random() * 14 - 7) + "px");
      bubble.style.setProperty("--drift-end", (Math.random() * 20 - 10) + "px");
      if (Math.random() < 0.3) {
        bubble.style.setProperty("--meander-amt", (Math.random() * 40 + 20) + "px");
        bubble.style.animationName = "riseMeander";
      }
      textContainer.appendChild(bubble);
      setTimeout(() => bubble.remove(), 14000);
    }
  }

  function ensureBubbles() {
    if (!bubbleInterval) {
      bubbleInterval = setInterval(createBubble, 600);
    }
  }

  // Hard-coded durations (ms) - keeps both screens in sync
  const VIDEO_DURATION = 6000;    // kaos_water.mp4 (matches KAOS_SIGN.mp4)
  const BUBBLE_DURATION = 13000;  // question (6s) + fade (1s) + ZOLTAR_ORANGE_2 (6s)
  const ANSWER_DURATION = 6000;   // matches down_arrow.mp4

  function clearTimers() {
    clearTimeout(stepTimeout);
    clearTimeout(outroTimeout);
    stepTimeout = null;
    outroTimeout = null;
  }

  // Step 1: Play kaos_water video
  function playKaosWater() {
    currentState = 'video';
    clearTimers();

    // Hide any text
    zoomText.style.opacity = '0';
    zoomText.style.transition = 'none';

    // Show and play video
    introVideo.style.display = 'block';
    introVideo.currentTime = 0;
    introVideo.play().catch(e => console.log('Video play failed:', e));

    // Hard cutoff after fixed duration
    stepTimeout = setTimeout(() => {
      introVideo.pause();
      introVideo.style.display = 'none';
      ensureBubbles();
      if (!frozen) showBubblePause(true);
    }, VIDEO_DURATION);
  }

  // Step 2: Bubbles-only pause between video/answers
  function showBubblePause(beforeAnswer) {
    currentState = 'bubbles';

    // Make sure text is hidden
    zoomText.style.opacity = '0';
    zoomText.style.transition = 'none';

    stepTimeout = setTimeout(() => {
      if (!frozen) {
        if (beforeAnswer) {
          showAnswer();
        } else {
          // After an answer: advance to next answer or loop
          currentAnswerIndex++;
          if (currentAnswerIndex >= textsWithRatings.length) {
            currentAnswerIndex = 0;
            playKaosWater();
          } else {
            showAnswer();
          }
        }
      }
    }, BUBBLE_DURATION);
  }

  // Step 3: Show answer text
  function showAnswer() {
    currentState = 'answer';
    const item = textsWithRatings[currentAnswerIndex];

    const hasPipes = item.text.includes("|");
    const lines = hasPipes ? item.text.split("|") : item.text.split(" ");
    const useWordWrap = !hasPipes && lines.length >= 4;
    const processedLines = useWordWrap ? findBestLineBreaks(lines) : lines;

    zoomText.style.transition = "none";
    zoomText.style.filter = "blur(20px)";
    zoomText.style.opacity = "0";
    zoomText.style.transform = "translate(-50%, 0) scale(0.6) rotate(-8deg)";

    zoomText.innerHTML = processedLines.map(line => `<span class="word">${line}</span>`).join("");
    zoomText.style.fontSize = item.fontSize || getTextStyle(processedLines, false).size;

    // Intro transition
    zoomText.style.transition = "filter 1.5s ease-out, opacity 1.5s ease-out, transform 1.5s ease-out";
    zoomText.style.filter = "blur(0)";
    zoomText.style.opacity = "1";
    zoomText.style.transform = "translate(-50%, 0) scale(1) rotate(0deg)";

    // Outro transition at 4.5s (intro 1.5s + visible + outro 1.5s = 6s total)
    outroTimeout = setTimeout(() => {
      const exitRotate = Math.random() * 30 - 15;
      zoomText.style.transition = "filter 1.5s ease-in, opacity 1.5s ease-in, transform 1.5s ease-in";
      zoomText.style.filter = "blur(18px)";
      zoomText.style.opacity = "0";
      zoomText.style.transform = `translate(-50%, 0) scale(0.35) rotate(${exitRotate}deg)`;
    }, ANSWER_DURATION - 1500);

    // After fixed answer duration, go to bubble pause
    stepTimeout = setTimeout(() => {
      if (!frozen) showBubblePause(false);
    }, ANSWER_DURATION);
  }

  // Navigate manually
  function goToAnswer(index) {
    clearTimers();
    introVideo.pause();
    introVideo.style.display = 'none';
    ensureBubbles();

    if (index < 0) index = textsWithRatings.length - 1;
    if (index >= textsWithRatings.length) index = 0;

    currentAnswerIndex = index;
    showAnswer();
  }

  // Text sizing helpers
  function getAvailableWidth() {
    return (textContainer.clientWidth || window.innerWidth) * 0.95;
  }

  function getAvailableHeight() {
    return (textContainer.clientHeight || window.innerHeight) * 0.95;
  }

  function measureWord(word, size) {
    measure.style.fontSize = size + "vmin";
    measure.textContent = word;
    return measure.getBoundingClientRect().width;
  }

  function measureLineHeight(size) {
    measure.style.fontSize = size + "vmin";
    measure.textContent = "X";
    return measure.getBoundingClientRect().height * 1.1;
  }

  function getTextStyle(lines, useWordWrap = false) {
    const availableWidth = getAvailableWidth();
    const availableHeight = getAvailableHeight();

    if (useWordWrap) {
      const words = lines[0].split(" ");
      const getLongestWord = (s) => Math.max(...words.map(w => measureWord(w, s)));
      let size = 120;
      while (size > 4) {
        const longestWordWidth = getLongestWord(size);
        if (longestWordWidth > availableWidth) { size--; continue; }
        const lineHeight = measureLineHeight(size);
        const wordsPerLine = Math.floor(availableWidth / (longestWordWidth * 0.6));
        const estimatedLines = Math.ceil(words.length / Math.max(wordsPerLine, 1));
        if (lineHeight * estimatedLines > availableHeight) { size--; continue; }
        break;
      }
      return { size: size + "vmin" };
    }

    const getWidestLine = (s) => Math.max(...lines.map(line => measureWord(line, s)));
    let size = 120;
    while (size > 4 && (getWidestLine(size) > availableWidth || measureLineHeight(size) * lines.length > availableHeight)) {
      size--;
    }
    return { size: size + "vmin" };
  }

  function balanceLines(words, numLines) {
    if (numLines >= words.length) return words.map(w => [w]);
    const lines = [];
    const wordsPerLine = words.length / numLines;
    let idx = 0;
    for (let i = 0; i < numLines; i++) {
      const targetEnd = Math.round((i + 1) * wordsPerLine);
      lines.push(words.slice(idx, targetEnd).join(" "));
      idx = targetEnd;
    }
    return lines;
  }

  function findBestLineBreaks(words) {
    const wordCount = words.length;
    let bestLines = words;
    let bestVariance = Infinity;
    for (let numLines = 2; numLines < wordCount; numLines++) {
      const lines = balanceLines(words, numLines);
      const lengths = lines.map(l => l.length);
      const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
      const variance = lengths.reduce((sum, len) => sum + Math.pow(len - avg, 2), 0) / lengths.length;
      if (variance < bestVariance) {
        bestVariance = variance;
        bestLines = lines;
      }
    }
    return bestLines;
  }

  // Keyboard handler
  function handleKey(code) {
    if (code === 'Space') {
      frozen = !frozen;
      if (frozen) {
        clearTimers();
        if (currentState === 'video') introVideo.pause();
      } else {
        if (currentState === 'video') {
          introVideo.play();
        } else if (currentState === 'answer') {
          showAnswer();
        } else {
          showBubblePause(true);
        }
      }
    }
    if (code === 'ArrowRight') {
      frozen = false;
      goToAnswer(currentAnswerIndex + 1);
    }
    if (code === 'ArrowLeft') {
      frozen = false;
      goToAnswer(currentAnswerIndex - 1);
    }
  }

  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowLeft' || e.code === 'ArrowRight') {
      e.preventDefault();
      handleKey(e.code);
    }
  });

  // Listen for forwarded keys from parent frame
  window.addEventListener('message', (e) => {
    if (e.data && e.data.type === 'kaos-key') {
      handleKey(e.data.code);
    }
  });

  // Autoplay setup
  introVideo.muted = true;
  introVideo.setAttribute('muted', '');
  introVideo.setAttribute('playsinline', '');
  introVideo.setAttribute('webkit-playsinline', '');
  introVideo.playsInline = true;

  // Start: play kaos_water video with hard-coded cutoff
  introVideo.load();
  introVideo.play().catch(() => {
    introVideo.style.display = 'none';
    ensureBubbles();
    if (!frozen) showBubblePause(true);
  });

  // Hard cutoff after fixed duration
  stepTimeout = setTimeout(() => {
    introVideo.pause();
    introVideo.style.display = 'none';
    ensureBubbles();
    if (!frozen) showBubblePause(true);
  }, VIDEO_DURATION);
</script>
</body>
</html>
