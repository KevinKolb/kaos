<html>
<head>
<link rel="icon" href="../8ball.svg" type="image/svg+xml" onerror="this.style.display='none'">
<title>Answers MAGA Hate Ball</title>
<style>
html, body {
  margin: 0;
  padding: 0;
  width: 100%;
  height: 100%;
  background: #4662bd;
  overflow: hidden;
  font-family: "Courier New", Courier, "Lucida Console", monospace;
  display: flex;
  align-items: center;
  justify-content: center;
}

#text-container {
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 100vw;
  height: 100vh;
  background: #4662bd;
}

#zoom-text {
  position: absolute;
  color: white;
  font-weight: bold;
  text-transform: uppercase;
  text-align: center;
  left: 50%;
  transform: translate(-50%, 0);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  height: 100vh;
  text-shadow:
    0 1px 0 rgba(150, 180, 255, 0.4),
    0 -1px 2px rgba(0, 0, 0, 0.6),
    0 3px 3px rgba(0, 0, 0, 0.7),
    0 6px 6px rgba(0, 0, 0, 0.5),
    0 10px 10px rgba(0, 0, 0, 0.3),
    0 0 15px rgba(100, 150, 255, 0.5);
  filter: blur(20px);
  opacity: 0;
  transition: filter 1.5s ease-out, opacity 1.5s ease-out, transform 1.5s ease-out; /* intro */
}

/* Line breaks defined per answer using | delimiter */
.word {
  display: block;
  white-space: nowrap;
}

.word.wrap {
  white-space: normal;
  word-wrap: break-word;
}

#measure {
  position: absolute;
  left: -9999px;
  top: -9999px;
  visibility: hidden;
  white-space: nowrap;
  font-family: "Courier New", Courier, "Lucida Console", monospace;
  font-weight: bold;
  letter-spacing: 0.1em;
  word-spacing: -0.2em;
  text-transform: uppercase;
}

.bubble {
  position: absolute;
  bottom: -20px;
  --drift-start: 0px;
  --drift-end: 0px;
  background:
    radial-gradient(circle at 30% 28%, rgba(150, 180, 255, 0.7), rgba(100, 140, 220, 0.15) 30%, rgba(60, 100, 180, 0.12) 45%, rgba(30, 60, 120, 0.08) 70%, rgba(15, 30, 60, 0) 90%),
    radial-gradient(circle at 70% 75%, rgba(80, 120, 200, 0.3), rgba(30, 50, 100, 0.1) 55%, rgba(15, 25, 50, 0) 85%);
  border-radius: 50%;
  box-shadow:
    inset 0 0 6px rgba(150, 180, 255, 0.35),
    inset 0 0 18px rgba(60, 100, 180, 0.2),
    0 2px 8px rgba(10, 20, 40, 0.4);
  mix-blend-mode: screen;
  filter: saturate(1.2);
  animation: rise linear infinite;
  pointer-events: none;
}

.bubble.front {
  z-index: 10;
}

.bubble.back {
  z-index: -1;
}

@keyframes rise {
  0% {
    transform: translate(var(--drift-start), 0) scale(1);
    opacity: 0.6;
  }
  50% {
    opacity: 0.4;
  }
  100% {
    transform: translate(var(--drift-end), -100vh) scale(0.55);
    opacity: 0;
  }
}

@keyframes riseMeander {
  0% {
    transform: translate(var(--drift-start), 0) scale(1);
    opacity: 0.6;
  }
  50% {
    transform: translate(calc(var(--drift-start) + var(--meander-amt)), -50vh) scale(0.75);
    opacity: 0.4;
  }
  100% {
    transform: translate(var(--drift-end), -100vh) scale(0.55);
    opacity: 0;
  }
}
</style>
</head>
<body>
<video id="intro-video" autoplay muted playsinline style="position:absolute; width:100%; height:100%; object-fit:cover; z-index:100;">
  <source src="../videos/kaos_water.mp4" type="video/mp4">
</video>
<div id="text-container">
  <div id="zoom-text"></div>
</div>
<script>
  // SEQUENTIAL MODE: cycle through all answers A-X
  const textsWithRatings = [
    { text: "GROCERIES", align: "center" },                                         // A
    { text: "BIGLY", align: "center" },                                             // B
    { text: "COVFEFE", align: "center" },                                           // C
    { text: "WITCH|HUNT", align: "center" },                                        // D
    { text: "IT'S|RIGGED", align: "center" },                                       // E
    { text: "IT'S A|HOAX", align: "center" },                                       // F
    { text: "NO.|IT'S FAKE|NEWS", align: "center" },                                // G
    { text: "THERE'S NO|COLLUSION", align: "center" },                              // H
    { text: "NO.|QUIET|PIGGY", align: "center" },                                   // I
    { text: "EVERYONE|AGREES", align: "center" },                                   // J
    { text: "NO.|SAD!", align: "center" },                                          // K
    { text: "YES.|DRILL BABY|DRILL", align: "center" },                             // L
    { text: "MANY PEOPLE ARE|SAYING NO", align: "center" },                         // M
    { text: "UNKNOWN.|JUST YELL|LOSERS", align: "center" },                         // N
    { text: "MANY PEOPLE ARE|SAYING YES", align: "center" },                        // O
    { text: "YES.|IT'S GONNA|BE HUGE", align: "center" },                           // P
    { text: "IT'S A|SCAM", align: "center" },                                       // Q
    { text: "WHAT A STUPID|QUESTION.|YES", align: "center" },                       // R
    { text: "ASK AGAIN LATER|DO MORE TARIFFS", align: "center" },                   // S
    { text: "JUST SAY|RUSSIA|RUSSIA|RUSSIA", align: "center" },                     // T
    { text: "YES. TELL PEOPLE TO|DRINK BLEACH", align: "center" },                  // U
    { text: "THEY'RE EATING|THE DOGS!", align: "center" },                          // V
    { text: "THE FAILING|NEW YORK TIMES|SAYS YES", align: "center" },               // W
    { text: "THANK YOU FOR YOUR|ATTENTION IN|THIS MATTER.|NO", align: "center" },   // X
    { text: "TBD|ANSWER 1", align: "center" },                                        // Y
    { text: "TBD|ANSWER 2", align: "center" },                                        // Z
    { text: "TBD|ANSWER 3", align: "center" },                                        // AA
  ];

  let answerIndex = 0;

  // Listen for locked answer index from parent - REMOVE THIS BLOCK
  // window.addEventListener('message', (event) => {
  //   if (event.data.type === 'answerIndex') {
  //     ...
  //   }
  // });

  const zoomText = document.getElementById("zoom-text");
  const textContainer = document.getElementById("text-container");
  const measure = document.createElement("div");
  measure.id = "measure";
  document.body.appendChild(measure);

  function createBubble() {
    const count = Math.random() < 0.5 ? 4 : 2;
    for (let i = 0; i < count; i++) {
      const bubble = document.createElement("div");
      bubble.className = "bubble";
      bubble.style.left = Math.random() * 100 + "%";
      const rand = Math.random();
      const size = rand < 0.02 ? Math.random() * 300 + 500   // 2%: gigantic
        : rand < 0.08 ? Math.random() * 200 + 250            // 6%: huge
        : rand < 0.25 ? Math.random() * 150 + 80             // 17%: large
        : Math.random() * 30 + 8;                            // 75%: small
      bubble.style.width = bubble.style.height = size + "px";
      bubble.style.bottom = (-size - 20) + "px";
      bubble.classList.add(Math.random() < 0.2 ? 'front' : 'back');
      bubble.style.animationDuration = (Math.random() * 15 + 3) + "s";
      bubble.style.animationDelay = (Math.random() * 1.2) + "s";
      bubble.style.setProperty("--drift-start", (Math.random() * 14 - 7) + "px");
      bubble.style.setProperty("--drift-end", (Math.random() * 20 - 10) + "px");
      if (Math.random() < 0.3) {
        bubble.style.setProperty("--meander-amt", (Math.random() * 40 + 20) + "px");
        bubble.style.animationName = "riseMeander";
      }
      textContainer.appendChild(bubble);
      setTimeout(() => bubble.remove(), 14000);
    }
  }
  // Bubbles start after intro video ends

  let frozen = false;
  let outroTimeout = null;
  let nextTimeout = null;
  let history = [];
  let historyIndex = -1;
  let reverseIndex = -1;

  document.addEventListener('keydown', (e) => {
    if (e.code === 'Space') {
      e.preventDefault();
      frozen = !frozen;
      if (frozen) {
        clearTimeout(outroTimeout);
        clearTimeout(nextTimeout);
        outroTimeout = null;
        nextTimeout = null;
      } else {
        showText();
      }
    }
    if (e.code === 'ArrowRight') {
      e.preventDefault();
      clearTimeout(outroTimeout);
      clearTimeout(nextTimeout);
      outroTimeout = null;
      nextTimeout = null;
      frozen = false;
      showText();
    }
    if (e.code === 'ArrowLeft') {
      e.preventDefault();
      clearTimeout(outroTimeout);
      clearTimeout(nextTimeout);
      outroTimeout = null;
      nextTimeout = null;
      frozen = false;
      if (historyIndex > 0) {
        historyIndex--;
        showItem(history[historyIndex]);
      } else {
        // At first item, wrap to end and go backward
        if (reverseIndex === -1) {
          reverseIndex = textsWithRatings.length - 1;
        } else {
          reverseIndex--;
          if (reverseIndex < 0) reverseIndex = textsWithRatings.length - 1;
        }
        showItem(textsWithRatings[reverseIndex]);
      }
    }
  });

  function getNextItem() {
    const item = textsWithRatings[answerIndex];
    answerIndex = (answerIndex + 1) % textsWithRatings.length;
    return item;
  }

  function getAvailableWidth() {
    return (textContainer.clientWidth || window.innerWidth) * 0.95;
  }

  function getAvailableHeight() {
    return (textContainer.clientHeight || window.innerHeight) * 0.95;
  }

  function measureWord(word, size) {
    measure.style.fontSize = size + "vmin";
    measure.textContent = word;
    return measure.getBoundingClientRect().width;
  }

  function measureLineHeight(size) {
    measure.style.fontSize = size + "vmin";
    measure.textContent = "X";
    return measure.getBoundingClientRect().height * 1.1; // line-height factor
  }

  function getTextStyle(lines, useWordWrap = false) {
    const availableWidth = getAvailableWidth();
    const availableHeight = getAvailableHeight();

    if (useWordWrap) {
      // For word wrap: size based on longest word and estimated lines
      const words = lines[0].split(" ");
      const getLongestWord = (s) => Math.max(...words.map(w => measureWord(w, s)));

      let size = 120;
      while (size > 4) {
        const longestWordWidth = getLongestWord(size);
        if (longestWordWidth > availableWidth) {
          size--;
          continue;
        }
        // Estimate lines needed at this size
        const lineHeight = measureLineHeight(size);
        const wordsPerLine = Math.floor(availableWidth / (longestWordWidth * 0.6)); // rough estimate
        const estimatedLines = Math.ceil(words.length / Math.max(wordsPerLine, 1));
        if (lineHeight * estimatedLines > availableHeight) {
          size--;
          continue;
        }
        break;
      }
      return { size: size + "vmin" };
    }

    // For one word per line
    const getWidestLine = (s) => Math.max(...lines.map(line => measureWord(line, s)));
    let size = 120;
    while (size > 4 && (getWidestLine(size) > availableWidth || measureLineHeight(size) * lines.length > availableHeight)) {
      size--;
    }
    return { size: size + "vmin" };
  }

  function balanceLines(words, numLines) {
    // Distribute words across lines to balance widths
    if (numLines >= words.length) return words.map(w => [w]);

    const lines = [];
    const wordsPerLine = words.length / numLines;
    let currentIndex = 0;

    for (let i = 0; i < numLines; i++) {
      const targetEnd = Math.round((i + 1) * wordsPerLine);
      const lineWords = words.slice(currentIndex, targetEnd);
      lines.push(lineWords.join(" "));
      currentIndex = targetEnd;
    }
    return lines;
  }

  function findBestLineBreaks(words) {
    // Try different line counts and find most balanced
    const wordCount = words.length;
    let bestLines = words; // default: one word per line
    let bestVariance = Infinity;

    // Try 2 to wordCount-1 lines
    for (let numLines = 2; numLines < wordCount; numLines++) {
      const lines = balanceLines(words, numLines);
      const lengths = lines.map(l => l.length);
      const avg = lengths.reduce((a, b) => a + b, 0) / lengths.length;
      const variance = lengths.reduce((sum, len) => sum + Math.pow(len - avg, 2), 0) / lengths.length;

      if (variance < bestVariance) {
        bestVariance = variance;
        bestLines = lines;
      }
    }
    return bestLines;
  }

  function showItem(item) {
    const hasPipes = item.text.includes("|");
    const lines = hasPipes ? item.text.split("|") : item.text.split(" ");
    const useWordWrap = !hasPipes && lines.length >= 4;
    const processedLines = useWordWrap ? findBestLineBreaks(lines) : lines;

    zoomText.style.transition = "none";
    zoomText.style.filter = "blur(20px)";
    zoomText.style.opacity = "0";
    zoomText.style.transform = "translate(-50%, 0) scale(0.6) rotate(-8deg)";

    zoomText.innerHTML = processedLines.map(line => `<span class="word">${line}</span>`).join("");
    zoomText.style.fontSize = item.fontSize || getTextStyle(processedLines, false).size;

    // Intro transition
    zoomText.style.transition = "filter 1.5s ease-out, opacity 1.5s ease-out, transform 1.5s ease-out";
    zoomText.style.filter = "blur(0)";
    zoomText.style.opacity = "1";
    zoomText.style.transform = "translate(-50%, 0) scale(1) rotate(0deg)";

    // Outro transition (starts at 4.5s so intro 1.5s + visible + outro 1.5s = 6s total)
    outroTimeout = setTimeout(() => {
      const exitRotate = Math.random() * 30 - 15;
      zoomText.style.transition = "filter 1.5s ease-in, opacity 1.5s ease-in, transform 1.5s ease-in";
      zoomText.style.filter = "blur(18px)";
      zoomText.style.opacity = "0";
      zoomText.style.transform = `translate(-50%, 0) scale(0.35) rotate(${exitRotate}deg)`;
    }, 4500);

    // 6s answer + 6.5s gap = 12.5s cycle (syncs with questions: 6s + 500ms delay + 6s video)
    nextTimeout = setTimeout(() => {
      nextTimeout = null;
      if (!frozen) showText();
    }, 12500);
  }

  function showText() {
    const item = getNextItem();
    history.push(item);
    historyIndex = history.length - 1;
    showItem(item);
  }

  // Wait for intro video to finish, then start bubbles and delay first answer
  const introVideo = document.getElementById('intro-video');
  let started = false;

  function startAfterVideo() {
    if (started) return;
    started = true;
    introVideo.style.display = 'none';
    // Start bubbles
    setInterval(createBubble, 600);
    // Hold 6.6s before first answer (syncs with questions: 500ms video delay + 6s video + 100ms offset)
    setTimeout(showText, 6600);
  }

  introVideo.addEventListener('ended', startAfterVideo);
  introVideo.addEventListener('error', startAfterVideo);

  // Safety timeout in case video events don't fire
  setTimeout(() => {
    if (!started) startAfterVideo();
  }, 7000);
</script>
</body>
</html>
